package day02_SWEA;

import java.util.Scanner;

public class Following {

	public static void main(String[] args) {

		// 입력을 위한 Scanner
		Scanner sc = new Scanner(System.in);

		// 테스트 케이스 수
		int T = sc.nextInt();
		// tc 반복문 결국 tc<= T라는 거지
		for (int tc = 1; tc <= T; tc++) {
			// 크기를 입력받아 배열을 생성한다.
			int N = sc.nextInt(); // N*N크기의 배열 1<=N<=10을 위해 만든 N
			int[][] arr = new int[N][N];// 정사각형이니까 가능 배열의 크기 선언

			// 판이 만들어지고 이동하는 방법을 구상해야 한다.
			// 맨 처음은 배열의 크기(N)만큼 이동하고 점점 줄어드는 방향으로 가야한다.
			int K = N; // 이동할 칸의 수
			int D = 1; // 증감한다고 어떻게????? D가 1이면 증가 D가 -1이면 감소인것 같다.

			// 현재 좌표를 구한다.
			int r = 0;// 얘는 맨처음 안더해지니까 0이여도 상관 ㄴ
			int c = -1;// 하나 전에서 출발 D가 c에 계속 더해져야 하는데 -1이여야 0,0부터 시작 가능
			int num = 1;
			// 이제 반복문을 통해 배열에 값을 달팽이 모양으로 집어넣을 수 있다.
			while (true) {
				// 가로 > 세로로 바뀌는 경우
				// 왜 N말고 K를 써야 하는가
				for (int i = 0; i < K; i++) {
					// 현재 위치의 좌표값
					c += D; // D값이 어느 부분에서 전환되는지 모르겠음
					arr[r][c] = num++;// 0-1(-1) 00(0) 02(1) 03(2).....0K(K)
					// 2차때 열 값이 줄어듦
				} // <- 수평채우기
				K--;// 수직이동은 수평이동보다 1작게 이동한다. 수평채우기가 끝나고 K가 줄어들어야 식이 성립
				if (K == 0)
					break; // 돌고돌아 수직이동할 거리가 0이 되면 종료

				for (int i = 0; i < K; i++) {
					r += D; // 행값이 증가한다.
					arr[r][c] = num++;// K가 고정 1K(K+1) 2K(K+2).....KK(K+K)
					// 2차때 행값이 줄어듦
				} // <- 수직채우기
				D = -D;// 여기에서 D의 음수 양수 전환이 일어난다!! 수직채우기가 끝나야 D의 방향전환이 가능하다.
			} // 달팽이를 모두 채울 수 있다. 반복을 통해서

			System.out.println("#" + tc);// 테스트 케이스 번호 보여주기
			// 이중 반복을 통해 전체 배열 출력
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					System.out.print(arr[i][j] + " ");
				}
				System.out.println();
			}

		}

	}

}
